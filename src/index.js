import React from 'react';
import ReactDOM from 'react-dom';
import mapboxgl from 'mapbox-gl';
import MapboxGeocoder from 'mapbox-gl-geocoder';
import turf from 'turf';
import turf_circle from '@turf/circle';
import debounce from 'debounce';

mapboxgl.accessToken = 'pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4M29iazA2Z2gycXA4N2pmbDZmangifQ.-g_vE53SD2WrJ6tFX7QHmA';

// for list and filtered list
var filterEl = document.getElementById('feature-filter');
var listingEl = document.getElementById('feature-listing');

// for circle and clear toolbar items
var cirTool = document.getElementById('circle');
var clsTool = document.getElementById('clearCircle');

// Holds visible restaurant features for filtering
var restaurants = [];

// Create a popup, but don't add it to the map yet.
var popup = new mapboxgl.Popup({
  closeButton: false
});

/** the feature that is generated by turf_circle */
var circleBuffer;
var circleCenter;


class Application extends React.Component {

  constructor(props: Props) {
    super(props);
    this.state = {
      lng: -77.034084142948,
      lat: 38.909671288923,
      zoom: 1.5
    };
  }



  componentDidMount() {
    const { lng, lat, zoom } = this.state;
    // read restaurant info from geojson file
    var res = require('./restaurants1.json');
    const map = new mapboxgl.Map({
      container: this.mapContainer,
      style: 'mapbox://styles/mapbox/streets-v9',
      center: [lng, lat],
      zoom: 13
    });
    addGeocoder();
    addNavTool();

    map.on('load', function () {

      map.addLayer({
        "id": "res1",
        "type": "symbol",
        "source": res,
        "layout": {
          "icon-image": "{icon}-15",
          "text-field": "{name}",
          "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
          "text-offset": [0, 0.6],
          "text-anchor": "top"
        }
      });

      /** add circle layers */

      // by default disable pan so circle drawing is on 
      map.dragPan.disable();
      map.scrollZoom.disable();

      //addToMap
      map.addSource('circle-2', {
        type: "geojson",
        data: null,   // no data in the beginning
        buffer: 1
      });

      map.addLayer({
        id: "circle-line1",
        type: "line",
        source: "circle-2",
        paint: {
          "line-color": "#fb6a4a"
        }
      });

      map.addLayer({
        id: "circle-fill1",
        type: "fill",
        source: "circle-2",
        paint: {
          "fill-color": "#fb6a4a",
          "fill-opacity": 0.5
        }
      });

      /** end adding circle layer */

      /** circle and clear toolbar */
      cirTool.addEventListener('click', function (e) {
        if ('active' === cirTool.className) {
          // change to unactive
          cirTool.className = '';
          map.dragPan.enable();
          map.scrollZoom.enable();
        } else {
          cirTool.className = 'active';
          map.dragPan.disable();
          map.scrollZoom.disable();
        }
      });


      clsTool.addEventListener('click', function (e) {
        // set source data as a null geojson object
        map.getSource('circle-2').setData({
          type: 'FeatureCollection',
          features:
          [{
            type: 'Feature',
            properties: {},
            geometry: null
          }]
        }
        );
      });
      /** end circle and clear toolbar */

      filterEl.addEventListener('keyup', function (e) {
        var value = normalize(e.target.value);

        // Filter visible features that don't match the input value.
        var filtered = restaurants.filter(function (feature) {
          var name = normalize(feature.properties.name);
          var code = normalize(feature.properties.address1);
          return name.indexOf(value) > -1 || code.indexOf(value) > -1;
        });

        // Populate the sidebar with filtered results
        renderListings(filtered);

        // Set the filter to populate features into the layer.
        map.setFilter('res1', ['in', 'address1'].concat(filtered.map(function (feature) {
          return feature.properties.name;
        })));
      });
      // Call this function on initialization
      // pass json data and render all points
      if (res && res.data)
        renderListings(res.data.features);

      /** Add map event listeners */
      map.on('zoomend', adjustCircle);

      map.on('mousedown', onMouseDown);
    });

    var adjustCircle = function () {
      console.log('circling');
      // map.getSource('circle-1').setData(turf.featureCollection(circleBuffer));
    }

    var onMousemove = function (e) {
      if (circleCenter) {
        var currPnt = {
          "type": "Feature",
          "properties": {},
          "geometry": {
            "type": "Point",
            "coordinates": [e.lngLat.lng, e.lngLat.lat]
          }
        };

        var cir_dis = turf.distance(circleCenter, currPnt, 'kilometers');
        var options = { steps: 60, units: 'kilometers', properties: { foo: 'bar' } };
        if (cir_dis && cir_dis > 0) {
          circleBuffer = turf_circle(circleCenter, cir_dis, options);
          var addToMap = [turf.point(circleCenter.geometry.coordinates), circleBuffer];
          map.getSource('circle-2').setData(turf.featureCollection(addToMap));
        }
      }

      /** Start spatial search of restaurants within the circle */
      var resFeatures = map.queryRenderedFeatures({ layers: ['res1'] });

      var resInCircle = resFeatures.filter(element => turf.inside(element, circleBuffer) === true);

      // update resaurant list for the restaurants in the current circle
      renderListings(getUniqueFeatures(resInCircle, 'name'));
      restaurants = getUniqueFeatures(resInCircle, 'name');
    }

    var onMouseUp = function (e) {
      if (circleCenter) {
        circleCenter = null;
      }

      // set back cursor
      map.getCanvas().style.cursor = '';

    }

    var onMouseDown = function (e) {
      if (cirTool.className !== 'active') {
        return;
      }

      var center = [e.lngLat.lng, e.lngLat.lat];
      var radius = 0.1;
      var options = { steps: 60, units: 'kilometers', properties: { foo: 'bar' } };
      circleBuffer = turf_circle(center, radius, options);

      circleCenter = {
        "type": "Feature",
        "properties": {},
        "geometry": {
          "type": "Point",
          "coordinates": [e.lngLat.lng, e.lngLat.lat]
        }
      };
      //addToMap
      var addToMap = [turf.point(center), circleBuffer];
      map.getSource('circle-2').setData(turf.featureCollection(addToMap));


      map.on('mousemove', debounce(onMousemove, 16));
      map.once('mouseup', onMouseUp);

      // change pointer to crosshair
      map.getCanvas().style.cursor = 'crosshair';
    };

    /**
     * Add markers to the map at all points
     */
    res.data.features.forEach(function (marker, i) {
      var el = document.createElement('div'); // Create an img element for the marker
      el.id = 'marker-' + i;
      el.className = 'marker';

      new mapboxgl.Marker(el, { offset: [0, 0] })
        .setLngLat(marker.geometry.coordinates)
        .addTo(map);

      el.addEventListener('click', function (e) {
        flyToStore(marker); // Fly to the point
        createPopUp(marker); // Close all other popups and display popup for clicked store
        var activeItem = document.getElementsByClassName('active'); // Highlight listing in sidebar (and remove highlight for all other listings)

        e.stopPropagation();
        if (activeItem[0]) {
          activeItem[0].classList.remove('active');
        }

      });
    });

    function addGeocoder() {
      var geocoder = new MapboxGeocoder({
        accessToken: mapboxgl.accessToken,
        bbox: [-77.210763, 38.803367, -76.853675, 39.052643]
      });

      map.addControl(geocoder, 'top-left');
    }

    function addNavTool() {
      var nav = new mapboxgl.NavigationControl();
      map.addControl(nav, 'top-right');
    }

    function flyToStore(currentFeature) {
      map.flyTo({
        center: currentFeature.geometry.coordinates,
        zoom: 15
      });
    }

    function createPopUp(currentFeature) {
      var popUps = document.getElementsByClassName('mapboxgl-popup');
      if (popUps[0]) popUps[0].remove();

      var popup = new mapboxgl.Popup({ closeOnClick: false })
        .setLngLat(currentFeature.geometry.coordinates)
        .setHTML('<h3>' + currentFeature.properties.name + '</h3>' +
        '<h4>' + currentFeature.properties.address1 + '</h4>')
        .addTo(map);
    }

    /**
     * populate restaurant list in the bottom right section
     * @param {*} features 
     */
    function renderListings(features) {
      // Clear any existing listings
      listingEl.innerHTML = '';
      if (features.length) {
        features.forEach(function (feature, i) {
          var prop = feature.properties;
          var item = document.createElement('a');
          item.href = '#';
          item.textContent = prop.name + ' (' + prop.address1 + ')';
          item.dataPosition = i;
          item.addEventListener('mouseover', function () {
            // Highlight corresponding feature on the map
            popup.setLngLat(feature.geometry.coordinates)
              .setText(feature.properties.name + ' (' + feature.properties.address1 + ')')
              .addTo(map);
          });
          item.addEventListener('click', function (e) {
            var clickedListing = features[this.dataPosition]; // Update the currentFeature to the store associated with the clicked link
            flyToStore(clickedListing); // Fly to the point
            createPopUp(clickedListing); // Close all other popups and display popup for clicked store
            var activeItem = document.getElementsByClassName('active'); // Highlight listing in sidebar (and remove highlight for all other listings)
            if (activeItem[0]) {
              activeItem[0].classList.remove('active');
            }
            this.parentNode.classList.add('active');
          });
          listingEl.appendChild(item);
        });

        // Show the filter input
        filterEl.parentNode.style.display = 'block';
      } else {
        var empty = document.createElement('p');
        empty.textContent = 'Drag the map to populate results';
        listingEl.appendChild(empty);

        // Hide the filter input
        filterEl.parentNode.style.display = 'none';

        // remove features filter
        map.setFilter('res1', ['has', 'name']);
      }
    }

    function normalize(string) {
      return string.trim().toLowerCase();
    }

    function getUniqueFeatures(array, comparatorProperty) {
      var existingFeatureKeys = {};
      // Because features come from tiled vector data, feature geometries may be split
      // or duplicated across tile boundaries and, as a result, features may appear
      // multiple times in query results.
      var uniqueFeatures = array.filter(function (el) {
        if (existingFeatureKeys[el.properties[comparatorProperty]]) {
          return false;
        } else {
          existingFeatureKeys[el.properties[comparatorProperty]] = true;
          return true;
        }
      });

      return uniqueFeatures;
    }

    function getFeaturesFromLayer(lyrName) {
      var features = map.queryRenderedFeatures({ layers: [lyrName] });

      if (features) {
        var uniqueFeatures = getUniqueFeatures(features, "name");
        // Populate features for the listing overlay.
        renderListings(uniqueFeatures);

        // Clear the input container
        filterEl.value = '';

        // Store the current features in sn `res1` variable to
        // later use for filtering on `keyup`.
        restaurants = uniqueFeatures;
      }
    }

    map.on('moveend', function () {
      getFeaturesFromLayer('res1');
    });

    map.on('move', () => {
      const { lng, lat } = map.getCenter();

      this.setState({
        lng: lng.toFixed(4),
        lat: lat.toFixed(4),
        zoom: map.getZoom().toFixed(2)
      });
    });
  }



  render() {
    const { lng, lat, zoom } = this.state;

    return (
      <div>

        <div ref={el => this.mapContainer = el} className="absolute top right left bottom" />

      </div>
    );
  }
}





ReactDOM.render(<Application />, document.getElementById('app'));
